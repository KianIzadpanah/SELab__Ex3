# مدیریت حساب بانکی

## اعضای گروه

کیان ایزدپناه - 400104783

امیر محمد درخشنده - 400101153

مهدی حاجی بیگی - 99109122

## بخش اول: کشف خطا

### پرسش اول

در برنامۀ مدیریت حساب بانکی، کلاسی به نام AccountBalanceCalculator تعریف شده است که وظیفۀ محاسبۀ موجودی نهایی حساب را بر اساس لیستی از تراکنش ها دارد. این کلاس همچنین دارای یک لیست استاتیک از تاریخچۀ تراکنش‌ها می‌باشد. در پیاده‌سازی اولیه، متد calculateBalance فقط عملیات محاسبه را انجام می‌داد و هیچ تغییری در transactionHistory نمی‌داد؛ بنابراین، تاریخچه‌ی تراکنش‌ها پس از محاسبه خالی یا نامربوط باقی می‌ماند.

دلیل اصلی چنین نقصی، این است که تست‌های قبلی فقط مقدار نهایی موجودی (balance) را بررسی می‌کردند و هیچ‌کدام بررسی نمی‌کردند که آیا تاریخچۀ تراکنش‌ها به‌درستی پس از محاسبه ذخیره شده است یا نه.

برای مثال، تست‌هایی مانند testOnlyDeposits یا testMixedTransactions فقط مقدار خروجی متد calculateBalance را ارزیابی می‌کنند و کاری به محتویات getTransactionHistory() ندارند.

حتی تست‌هایی که به تاریخچه مربوط بودند (مثل testTransactionHistoryShouldBeEmptyBeforeCalculatingBalance) صرفاً وضعیت قبل از محاسبه را بررسی می‌کردند و نه بعد از آن. در نتیجه، چون بررسی صریحی برای محتوای تاریخچه پس از محاسبه وجود نداشت، این نقص عملکردی توسط تست‌ها شناسایی نشده بود. در تصویر زیر پاس شدن تمامی تست ها با وجود چنین اشکالی را می توانیم مشاهده کنیم:

![](./images/1.png)

---

### پرسش دوم

جهت بررسی صحت رفتار مورد انتظار، تست زیر نوشته شد:

![](./images/2.png)

هدف این تست آن است که بررسی کند آیا پس از فراخوانی calculateBalance، تاریخچۀ تراکنش‌ها به درستی با ورودی مطابقت دارد یا خیر. قبل از اعمال تغییرات، اجرای این تست با شکست مواجه شد که نشان داد برنامه رفتار مورد انتظار را ندارد و تاریخچه به‌روز نمی‌شود. این شکست در تصویر زیر قابل مشاهده است:

![](./images/3.png)

برای رفع مشکل، کد متد calculateBalance به صورت زیر اصلاح شد:

![](./images/4.png)

با این تغییر، همه‌ی تست‌ها، از جمله تست جدید اضافه‌شده، با موفقیت اجرا شدند. این نشان‌دهندۀ صحت عملکرد و اصلاح درست باگ بود. این اجرای موفقیت آمیز در تصویر زیر قابل مشاهده است:

![](./images/5.png)

---

### پرسش سوم

نوشتن تست پس از پیاده‌سازی برنامه می‌تواند باعث شود برخی رفتارهای مورد انتظار (مثل به‌روزرسانی تاریخچه تراکنش‌ها) اصلاً بررسی نشوند، چون تمرکز تست‌ها بر کدی است که وجود دارد نه بر نیازمندی واقعی. این رویکرد همچنین احتمال باقی ماندن باگ‌های منطقی را بالا می‌برد و حس کاذبی از درستی کامل سیستم ایجاد می‌کند. از طرفی، اصلاح کد برای تطابق با رفتار صحیح پس از نوشتن تست‌ها معمولاً پیچیده‌تر و پرهزینه‌تر است. تجربه‌ی این تمرین نشان داد که نوشتن تست قبل یا هم‌زمان با کدنویسی، باعث درک بهتر نیازمندی‌ها و کشف زودهنگام خطاها می‌شود. در نتیجه، کیفیت نرم‌افزار و اطمینان از صحت عملکرد آن به‌طور چشم‌گیری افزایش می‌یابد.

### پرسش چهارم
شفاف‌سازی نیازمندی‌ها و هدف‌گذاری دقیق:

چگونه تسهیل می‌شود؟ قبل از نوشتن حتی یک خط کد پیاده‌سازی اصلی، شما مجبور هستید که دقیقاً تعریف کنید آن بخش از برنامه قرار است چه کاری انجام دهد و در برابر ورودی‌های مختلف چه خروجی یا رفتاری باید داشته باشد. نوشتن تست یعنی تبدیل کردن یک نیاز کلی به یک سناریوی عملی و قابل اندازه‌گیری. این کار ابهام در نیازمندی‌ها را از بین می‌برد.
مقایسه با روش قبل: در روش کد-اول، گاهی اوقات بدون درک کامل جزئیات، شروع به کدنویسی می‌کنید و ممکن است در میانه راه متوجه شوید که نیازها را اشتباه فهمیده‌اید یا به حالت‌های مرزی (Edge Cases) فکر نکرده‌اید، که منجر به بازنگری و اصلاحات پرهزینه می‌شود.
تمرکز بر روی یک قطعه کوچک در هر لحظه:

چگونه تسهیل می‌شود؟ TDD شما را تشویق می‌کند تا برای هر تکه کوچک از functionality یک تست بنویسید. سپس فقط روی نوشتن کدی تمرکز می‌کنید که آن یک تست مشخص را پاس کند. این باعث می‌شود که مسئله بزرگ‌تر به بخش‌های کوچک و قابل مدیریت تقسیم شود.
مقایسه با روش قبل: در روش کد-اول، ممکن است سعی کنید چندین بخش یا کل functionality را یکجا پیاده‌سازی کنید که این پیچیدگی را افزایش داده و اشکال‌زدایی را دشوارتر می‌کند.
ارائه یک مسیر مشخص و راهنما (Red-Green-Refactor):

چگونه تسهیل می‌شود؟ چرخه TDD (قرمز: تست شکست می‌خورد -> سبز: کد می‌نویسیم تا تست پاس شود -> بازآرایی: کد را تمیز می‌کنیم) یک گام به گام مشخص برای پیشروی ارائه می‌دهد. تست شکست‌خورده (قرمز) به شما می‌گوید چه چیزی کم دارید و تست پاس‌شده (سبز) نشان می‌دهد که به هدف رسیده‌اید.
مقایسه با روش قبل: بدون تست‌های راهنما، ممکن است در فرآیند کدنویسی سردرگم شوید، ندانید دقیقاً چه زمانی کار یک بخش تمام شده است و یا اینکه آیا کد نوشته شده واقعاً تمام سناریوهای مورد انتظار را پوشش می‌دهد یا خیر.
تشویق به طراحی بهتر و قابل تست‌تر:

چگونه تسهیل می‌شود؟ برای اینکه بتوانید یک بخش را به راحتی تست کنید، آن بخش باید مستقل‌تر (وابستگی کمتر) و با رابط‌های مشخص باشد. نوشتن تست قبل از کد، شما را مجبور می‌کند از ابتدا به قابلیت تست‌پذیری فکر کنید که این اغلب منجر به طراحی ماژولارتر و تمیزتر می‌شود. طراحی خوب، خود فرآیند کدنویسی و نگهداری بعدی را تسهیل می‌کند.
مقایسه با روش قبل: در روش کد-اول، ممکن است کدی با وابستگی‌های زیاد و توابع بزرگ و پیچیده بنویسید که بعداً تست کردن آن بسیار دشوار یا غیرممکن باشد.
اشکال‌زدایی سریع‌تر و آسان‌تر:

چگونه تسهیل می‌شود؟ چون برای هر بخش کوچک تست نوشته‌اید و تست‌ها را بلافاصله پس از نوشتن کد مربوط به آن اجرا می‌کنید، اگر خطایی وجود داشته باشد، به سرعت و درست در همان قطعه کوچکی که مشغول کدنویسی آن بوده‌اید، شناسایی می‌شود. رفع اشکال در کد کم و تازه نوشته‌شده بسیار ساده‌تر از پیدا کردن آن در میان حجم زیادی کد قدیمی است.
مقایسه با روش قبل: در روش کد-اول، خطاها ممکن است دیرتر و در مراحل تست نهایی یا حتی پس از انتشار برنامه بروز کنند، و پیدا کردن ریشه خطا در میان بخش‌های مختلف برنامه بسیار زمان‌بر و دشوار خواهد بود.


### پرسش پنجم
مزایا (Advantages):
افزایش کیفیت کد و کاهش خطا:

چون کد برای پاس کردن تست‌های مشخص نوشته می‌شود، احتمال اینکه کد مطابق با نیازمندی‌ها باشد بیشتر است.
تست‌ها به عنوان یک تور ایمنی (Safety Net) عمل می‌کنند؛ با هر تغییری، می‌توان تست‌ها را اجرا کرد تا مطمئن شد که تغییرات باعث ایجاد رگرسیون (Regression) یا خطاهای جدید در بخش‌های دیگر نشده‌اند. این امر به خصوص در پروژه‌های بزرگ و طولانی‌مدت بسیار ارزشمند است.
طراحی بهتر و ماژولارتر:

برای اینکه کد قابل تست باشد، معمولاً باید به واحدهای کوچک‌تر و با وابستگی‌های کمتر (Loosely Coupled) تقسیم شود. TDD توسعه‌دهندگان را مجبور می‌کند که از ابتدا به رابط‌ها (Interfaces) و قابلیت تست‌پذیری کد فکر کنند که اغلب منجر به طراحی تمیزتر و ماژولارتر می‌شود.
مستندسازی زنده (Living Documentation):

تست‌ها به صورت عملی نشان می‌دهند که هر بخش از کد چگونه باید استفاده شود و چه انتظاراتی از آن می‌رود. این مستندات همیشه به‌روز هستند، زیرا اگر تست‌ها پاس نشوند، کد کار نمی‌کند.
افزایش اعتماد به نفس توسعه‌دهندگان:

وجود مجموعه تست‌های جامع به تیم‌ها و توسعه‌دهندگان این اطمینان را می‌دهد که می‌توانند کد را تغییر دهند یا بازآرایی کنند بدون اینکه نگران شکستن ناخواسته بخش‌های دیگر سیستم باشند.
کاهش زمان اشکال‌زدایی (Debugging):

خطاها معمولاً در همان مراحل اولیه توسعه و نزدیک به زمان ایجادشان شناسایی می‌شوند، که رفع آن‌ها را بسیار ساده‌تر و کم‌هزینه‌تر می‌کند.
معایب (Disadvantages):
کندی اولیه در روند توسعه:

نوشتن تست‌ها قبل از کد، به خصوص برای کسانی که تازه با TDD شروع کرده‌اند، می‌تواند زمان‌بر باشد و باعث شود سرعت اولیه توسعه کندتر به نظر برسد. اگرچه طرفداران TDD معتقدند این زمان در بلندمدت با کاهش زمان دیباگ و نگهداری جبران می‌شود.
منحنی یادگیری (Learning Curve):

یادگیری نوشتن تست‌های خوب و موثر، خود یک مهارت است. تست‌های بد می‌توانند شکننده باشند (با کوچک‌ترین تغییر غیرمرتبطی شکست بخورند) یا پوشش ناکافی داشته باشند و حس امنیت کاذب ایجاد کنند.
نیاز به نگهداری تست‌ها:

تست‌ها خودشان کد هستند و با تغییر نیازمندی‌ها یا بازآرایی کد اصلی، نیاز به به‌روزرسانی و نگهداری دارند. اگر تست‌ها به خوبی مدیریت نشوند، می‌توانند به یک بار اضافی تبدیل شوند.
دشواری در برخی حوزه‌ها:

اعمال TDD برای برخی بخش‌ها مانند رابط کاربری (UI)، کار با پایگاه‌داده‌های پیچیده، یا سیستم‌های با وابستگی‌های خارجی زیاد، می‌تواند چالش‌برانگیزتر باشد و نیاز به ابزارها و تکنیک‌های خاصی (مانند Mocking) دارد.
احتمال تمرکز بیش از حد بر واحدهای کوچک:

گاهی تمرکز زیاد روی تست‌های واحد (Unit Tests) ممکن است باعث شود تصویر کلی سیستم و تست‌های سطح بالاتر (مانند تست‌های یکپارچه‌سازی یا End-to-End) نادیده گرفته شوند.
نیاز به نظم و انضباط تیمی:

موفقیت TDD به شدت به پایبندی و نظم تیم در پیروی از چرخه Red-Green-Refactor بستگی دارد. اگر تیم این فرآیند را به صورت ناقص انجام دهد، ممکن است مزایای آن به دست نیاید.